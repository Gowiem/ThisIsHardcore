#!/usr/bin/env python
# encoding: utf-8

artisan_key, artisan_version, resource_download_url = '51886333369b05380e000033', '1.0', 'https://s3.amazonaws.com/artisan-releases/artisan-sdk-1.1.3.tar.gz'

xcode_project_path = ''
app_delegate_path = ''
xcode_version = ''
installer_version = '1.1.3'
application_target = ''

"""
Install Artisan automagically.
"""

import re
import os
import sys
import fileinput
import fnmatch
import urllib2
import shutil
import tarfile
import hashlib

from sys import stdout
from optparse import OptionParser
from zipfile import ZipFile as zip


## Hashing ##########################
def get_hash_base(resource_name):
		examplehash = 'AA0FFFEEEDDDCCCBBBAAA000'
		uniquehash = hashlib.sha224(resource_name).hexdigest().upper()
		uniquehash = uniquehash[:len(examplehash) - 4]
		return 'AA0'+uniquehash
####################################

## Project Creation ################
def get_base_project_id(file_name):

	project_file = open(file_name, 'r')

	for line in project_file:
		match = re.match("\s*.*rootObject = (?P<main_project_hash>.*) \/\* Project object \*\/;", line)
		if match:
			project_file.close()
			return match.group("main_project_hash")

	project_file.close()
	return ""

def get_project_build_info(path_to_project_file):

	project = {}
	file_name = path_to_project_file
	
	project["id"] = get_base_project_id(file_name)
	
	project_properties = get_properties_for_id(file_name, project["id"])

	project["buildConfigId"] = get_build_config_from_properties(project_properties)
	project["mainGroupId"] = get_value_for_property("mainGroup", project_properties)
	targets = get_thing_with_delimeters("targets", "(", ",", ")", project_properties)
	project["targets"] = {}
	
	for key, value in targets.items():
		target_build_properties = get_properties_for_id(file_name, value)
		target_build_config_id = get_build_config_from_properties(target_build_properties)

		target_build_config_properties = get_properties_for_id(file_name, target_build_config_id)
		target_build_configs = get_thing_with_delimeters("buildConfigurations", "(", ",", ")", target_build_config_properties)		

		target = {}
		target["id"] = value
		target["buildConfigListId"] = target_build_config_id
		target["buildConfigurations"] = {}

		for k, v in target_build_configs.items():

			tbc_properties = get_properties_for_id(file_name, v)
			baseConfigurationRef = get_thing_with_delimeters("baseConfigurationReference", "", ",", "", tbc_properties)
	
			target["buildConfigurations"][k] = {}
			target["buildConfigurations"][k]["id"] = v
			target["buildConfigurations"][k]["baseConfigurationReference"] = baseConfigurationRef

		project["targets"][key] = target

	return project

def get_project_data(path_to_project):
	
	if not os.path.exists(path_to_project):
		return None

	project_file = open(path_to_project, 'r')
	project_data = project_file.read()
	project_file.close()

	return project_data
####################################

## Group Methods ###################

def add_group(group_name, group_id, project_data):
	
	project_data = remove_group(group_name, project_data)
	match = re.search("\/\* Begin PBXGroup section \*\/", project_data)

	if not match:
		return

	lines  = "\n\t\t" + group_id + " /* " + group_name + " */ = {\n"
	lines += "\t\t\t" + "isa = PBXGroup;\n"
	lines += "\t\t\t" + "children = (\n"
	lines += "\t\t\t" + ");\n"
	lines += "\t\t\t" + "name = " + group_name + ";\n"
	lines += "\t\t\t" + "sourceTree = \"<group>\";\n"
	lines += "\t\t};"

	return add_lines_between_match(lines, match, project_data)

def remove_group(group_name, project_data):

	pattern_to_remove = "\n\t\t[A-Z0-9]+? \/\* " + group_name + " \*\/ = \{.*?sourceTree = \"<group>\";\n\t\t\};"
	compiled_pattern = re.compile(pattern_to_remove, re.MULTILINE | re.DOTALL)

	match = re.search(compiled_pattern, project_data)
	
	project_data = re.sub(compiled_pattern, "", project_data)

	return project_data

def add_file_reference_to_group(file_name, file_id, group_name, project_data):

	pattern_to_find = "\/\* Begin PBXGroup section \*\/.*\n\t\t[A-Z0-9]+? \/\* " + group_name + " \*\/ = \{.*?children = \("
	
	compiled_pattern = re.compile(pattern_to_find, re.MULTILINE | re.DOTALL)

	match = re.search(compiled_pattern, project_data)
	if not match:
		return project_data

	lines = "\n\t\t\t\t" + file_id + " /* " + file_name + " */,"

	project_data = add_lines_between_match(lines, match, project_data);
	return project_data

def add_file_reference_to_group_id(file_name, file_id, group_id, project_data):
	
	project_data = remove_file_reference_from_group_id(file_name, group_id, project_data)
	pattern_to_find = "\/\* Begin PBXGroup section \*\/.*\n\t\t" + group_id + "[ \/\* .*? \*\/]? = \{.*?children = \("
	compiled_pattern = re.compile(pattern_to_find, re.MULTILINE | re.DOTALL)

	match = re.search(compiled_pattern, project_data)
	if not match:
		return project_data

	lines = "\n\t\t\t\t" + file_id + " /* " + file_name + " */,"

	project_data = add_lines_between_match(lines, match, project_data);
	return project_data
	
def remove_file_reference_from_group(file_name, group_name, project_data):

	pattern_to_find = "\n\t\t[A-Z0-9]+? \/\* " + group_name + " \*\/ = \{.*?children = \("
	compiled_pattern = re.compile(pattern_to_find, re.MULTILINE | re.DOTALL)

	children_pattern = "(?P<start>.*\n\t\t[A-Z0-9]+? \/\* " + group_name + " \*\/ = \{.*?children = \()(?P<children>.*?,\n)(?P<end>\t\t\t\);.*)"
	children_pattern_c = re.compile(children_pattern, re.MULTILINE | re.DOTALL)

	match = re.match(children_pattern_c, project_data)
	if match:
		old_lines = match.group("children")
		new_lines = re.sub("\t\t\t\t[A-Z0-9]+ \/\* " + file_name + " \*\/,\n", "", old_lines)
		

	project_data = match.group("start") + new_lines + match.group("end")

	return project_data

def remove_file_reference_from_group_id(file_name, group_id, project_data):

	pattern_to_find = "\n\t\t" + group_id + "[ \/\* .*? \*\/]? = \{.*?children = \("
	compiled_pattern = re.compile(pattern_to_find, re.MULTILINE | re.DOTALL)

	children_pattern = "(?P<start>.*\n\t\t" + group_id + "[ \/\* .*? \*\/]? = \{.*?children = \()(?P<children>.*?,\n)(?P<end>\t\t\t\);.*)"
	children_pattern_c = re.compile(children_pattern, re.MULTILINE | re.DOTALL)

	match = re.match(children_pattern_c, project_data)
	if match:
		old_lines = match.group("children")
		new_lines = re.sub("\t\t\t\t[A-Z0-9]+ \/\* " + file_name + " \*\/,\n", "", old_lines)
		project_data = match.group("start") + new_lines + match.group("end")

	return project_data

####################################

## File Reference Methods ##########
def remove_file_reference(file_name, project_data):

	pattern_to_remove = '\s*.* \/\* '+ file_name +' \*\/ = \{isa = PBXFileReference; .*?};'

	matches = re.findall(pattern_to_remove, project_data)

	project_data = re.sub(pattern_to_remove, '', project_data)

	if matches:
		return (project_data, True)

	return (project_data, False)
	

def add_file_reference(file_name, file_id, file_type, file_path, project_data, project_file_path, source_tree):

	match = re.search('([A-Z0-9]+) \/\* '+re.escape(file_name)+' \*\/ = \{isa = PBXFileReference; .*?};', project_data)

	if match:
		return (project_data, False)

	match = re.search("\/\* Begin PBXFileReference section \*\/", project_data);

	if not match:
		return (project_data, False)

	line_to_add = "\n\t\t" + file_id + " /* " + file_name + " */ = {isa = PBXFileReference; lastKnownFileType = \"" + file_type + "\"; name = " + file_name + "; path = " + file_path+"/"+file_name + "; sourceTree = " + source_tree +"; };"

	project_data = project_data[:match.end()] + line_to_add + project_data[match.end():]

	return (project_data, True)

## Build File Methods #############
def add_build_file(file_name, file_id, build_file_id, build_type, project_data):

	match = re.search('([A-Z0-9]+).+?fileRef = '+re.escape(file_id), project_data)
	if match:
		return (project_data, False)

	match = re.search('\/\* Begin PBXBuildFile section \*\/', project_data)

	if not match:
		return (project_data, False)

	line_to_add = "\n\t\t" + build_file_id + " /* " + file_name + " in " + build_type + " */ = {isa = PBXBuildFile; fileRef = " + file_id + " /* " + file_name + " */; };"

	project_data = project_data[:match.end()] + line_to_add + project_data[match.end():]

	return (project_data, True)

def remove_build_file(resource_name, project_data):

	pattern_to_remove = "\s*.* \/\* " + resource_name + " in .* \*\/ = \{isa = PBXBuildFile;.*; \};"

	matches = re.findall(pattern_to_remove, project_data) 
	project_data = re.sub(pattern_to_remove, '', project_data)

	if matches:
		return (project_data, True)

	return (project_data, False)

## Property Modification Methods ###
def get_properties_for_id(file_name, id):

	project_file = open(file_name, 'r')

	start = False	
	properties = ""

	for line in project_file:

		if not start:
			match = re.match("(?P<spacing>\s*)"+id+" \/\* (?P<type>.*) \*\/ = \{", line)
			if match:
				start = True
				spacing = match.group("spacing")
		else:
			match = re.match(spacing+"};", line)
			if match:
				project_file.close()
				break

			else:
				properties += (line.strip()) + " "

	return properties

def remove_property_from_id(file_name, ID, property_name, property_value):

	removed_property = False
	single_line_replace = False

	property_list_string = get_properties_for_id(file_name, ID);
	current_values = get_array_with_delimeters(property_name, "(", ",", ")", property_list_string)
	current_value = get_value_for_property(property_name, property_list_string)

	if current_values and ("\""+property_value+"\"" in current_values or property_value in current_values):		
		array_replace = True
	if current_value:
		single_line_replace = True

	start = False
	in_property_array = False
	in_build_settings = False
	added_property_value = False
	should_skip_line = False

	for line in fileinput.input(file_name, inplace=True):

		if not start:
			match = re.match("(?P<spacing>\s*)"+ID+" \/\* (?P<type>.*) \*\/ = \{", line)
			if match:
				start = True
				spacing = match.group("spacing")
				
		else:	

			if not in_build_settings:
				match = re.match("(?P<build_settings_spacing>\s*)buildSettings = \{", line)
				if match:
					in_build_settings = True
					build_settings_spacing = match.group("build_settings_spacing")
			else:
				if single_line_replace:
					match = re.match("\s+"+property_name+" = .*", line)
					if match:
						single_line_replace = False
						should_skip_line = True
						removed_property = True

				match = re.match(build_settings_spacing+"\};", line)
				if match:
					in_build_settings = False

				if not in_property_array:
					match = re.match("(?P<prop_spacing>\s*)" + property_name + " = \(", line)
					if match:
						in_property_array = True;
						property_spacing = match.group("prop_spacing")
				else:
					match = re.match(property_spacing+"\);", line)
					if match:						
						in_property_array = False
					match = re.match(property_spacing+"\t\""+property_value+"\",", line)
					if match:
						should_skip_line = True
						removed_property = True

			match = re.match(spacing+"};", line)
			if match:
				start = False

		if not should_skip_line:
			sys.stdout.write(line)

		should_skip_line = False

	fileinput.close()
	return removed_property

def add_file_to_group(project_data, name, guid, group):

	match = re.search('\/\* '+re.escape(group)+' \*\/ = \{\n[ \t]+isa = PBXGroup;\n[ \t]+children = \(\n((?:.|\n)+?)\);', project_data)
	if not match:
		return project_data

	(children,) = match.groups()
	match = re.search(re.escape(guid), children)
	if not match:
		# not already there
		match = re.search('\/\* '+re.escape(group)+' \*\/ = \{\n[ \t]+isa = PBXGroup;\n[ \t]+children = \(\n', project_data)

		if not match:
			return project_data

		pbxgroup = "\t\t\t\t"+guid+" /* "+name+" */,\n"
		project_data = project_data[:match.end()] + pbxgroup + project_data[match.end():]

	return project_data

def add_file_to_phase(project_data, name, guid, phase, phase_guid):

	match = re.search('\/\*\s' + phase + '\s\*\/ = \{\n[ \t]+isa = PBX' + phase + 'BuildPhase;\n.*?\n\s*?files = \(\n((?:.|\n)+?)\);', project_data)

	if not match:
		return project_data
	else:
		(files, ) = match.groups()

	match = re.search(re.escape(guid), files)
	if not match:
		# not already there
		match = re.search(re.escape(phase_guid)+" \/\* "+phase+" \*\/ = {(?:.|\n)+?files = \(\n", project_data)
		if not match:
			return project_data

		frameworktext = "\t\t\t\t"+guid+" /* "+name+" in "+phase+" */,\n"
		project_data = project_data[:match.end()] + frameworktext + project_data[match.end():]

	return project_data

def add_property_to_id(file_name, ID, property_name, property_value):

	# this currently only will work for properties that accept the array type, other properties will
	# make xcode fail to recognize this file

	single_line_replace = False
	added_value = False

	property_list_string = get_properties_for_id(file_name, ID);
	current_values = get_array_with_delimeters(property_name, "(", ",", ")", property_list_string)
	current_value = get_value_for_property(property_name, property_list_string)

	if current_values and ("\""+property_value+"\"" in current_values or property_value in current_values):
		return False
	if current_value:
		single_line_replace = True
	

	start = False
	in_property_array = False
	in_build_settings = False
	added_property_value = False
	should_skip_line = False
	

	for line in fileinput.input(file_name, inplace=True):

		if not start:
			match = re.match("(?P<spacing>\s*)"+ID+" \/\* (?P<type>.*) \*\/ = \{", line)
			if match:
				start = True
				spacing = match.group("spacing")
				
		else:			

			if not in_build_settings:
				match = re.match("(?P<build_settings_spacing>\s*)buildSettings = \{", line)
				if match:
					in_build_settings = True
					build_settings_spacing = match.group("build_settings_spacing")
			else:

				if single_line_replace:
					match = re.match("\s+"+property_name+" = .*", line)
					if match:
						single_line_replace = False
						should_skip_line = True

				match = re.match(build_settings_spacing+"\};", line)
				if match and not added_property_value:
					sys.stdout.write(build_settings_spacing+"\t"+property_name+" = (\n")
					if current_value:
						sys.stdout.write(build_settings_spacing+"\t\t\"" + current_value + "\",\n")	
					if current_value != property_value:
						sys.stdout.write(build_settings_spacing+"\t\t\"" + property_value + "\",\n")
						added_value = True
					sys.stdout.write(build_settings_spacing+"\t);\n")						
				if match:
					in_build_settings = False

				if not in_property_array:
					match = re.match("(?P<prop_spacing>\s*)" + property_name + " = \(", line)
					if match:
						in_property_array = True;
						property_spacing = match.group("prop_spacing")
				else:
					match = re.match(property_spacing+"\);", line)
					if match:
						sys.stdout.write(property_spacing+"\t\"" + property_value + "\",\n")
						in_property_array = False
						added_value = True
						added_property_value = True

			match = re.match(spacing+"};", line)
			if match:
				start = False

		if not should_skip_line:
			sys.stdout.write(line)

		should_skip_line = False

	fileinput.close()

	if added_value:
		print "    + set " + property_name + " to " + property_value
	else:
		print "    = " + property_name + " already set to " + property_value
	return added_value

##############################################

## Configuration Modification ################

def remove_lines_containing_string(file_name, string_to_find):

	for line in fileinput.input(file_name, inplace=True):
		if string_to_find not in line:
			sys.stdout.write(line)

	fileinput.close()

def replace_string_in_file(file_name, replaced, replacer):

	for line in fileinput.input(file_name, inplace=True):
		sys.stdout.write(line.replace(replaced, replacer))

	fileinput.close()

def replace_other_ldflags(file_name):

	replace_string_in_file(file_name, "SHARED_OTHER_LDFLAGS", "_SHARED_OTHER_LDFLAGS")
	replace_string_in_file(file_name, "OTHER_LDFLAGS", "SHARED_OTHER_LDFLAGS")
 
def undo_other_ldflags(file_name):

	replace_string_in_file(file_name, "SHARED_OTHER_LDFLAGS", "OTHER_LDFLAGS")
	replace_string_in_file(file_name, "_SHARED_OTHER_LDFLAGS", "SHARED_OTHER_LDFLAGS")

def add_artisan_config(file_name, settings):

	file_name_abs = os.path.split(os.path.abspath(file_name))[0]
	config_rel_path = os.path.relpath(settings["xcode_project_path"]+"/../resources/Artisan.xcconfig", file_name_abs)

	config_file = open(file_name, 'a');
	config_file.write("\n#include \"" + config_rel_path + "\"")
	config_file.close()

def remove_artisan_xcconfig(file_name, settings):

	remove_lines_containing_string(file_name, 'Artisan.xcconfig')
		
def write_artisan_xcconfig(settings):

	artisan_xcconfig = settings["xcode_project_path"] + "/../resources/Artisan.xcconfig"

	config_file = open(artisan_xcconfig, 'w+')
	config_file.write("OTHER_LDFLAGS = ${SHARED_OTHER_LDFLAGS} -ObjC\n")
	config_file.write("FRAMEWORK_SEARCH_PATHS = \"$(SRCROOT)/resources\"")
	config_file.close()

def find_config_files(settings):

	project_data = get_project_data(settings["project_file"])

	for match in re.finditer('([A-Z0-9]+) \/\* (?P<config_file>.*) \*\/ = \{isa = PBXFileReference;.* lastKnownFileType = \"?text.xcconfig\"?;( name = (.*);)? path = \"?(?P<path>.*)\"?; sourceTree = .*};', project_data):
			
		config_file_name = match.group('config_file')
		config_file_path = match.group('path').replace("\"", "")

	rootDir = settings["xcode_project_path"]+'/../' # set the directory you want to start from

	found_files = []
	for dirName, subdirList, fileList in os.walk(rootDir):
		for filename in fnmatch.filter(fileList, '*.xcconfig'):				
			found_files.append(dirName+'/'+filename)

	return found_files;


## General Processing ########################
def get_build_config_from_properties(properties):
	match = re.match(".*buildConfigurationList = (?P<config_id>.*) \/\* Build configuration list for (?P<type>.*) \"(?P<project_name>.*)\" \*\/;.*", properties)
	if match:
		return match.group("config_id")
	else:
		return "No Config"


def get_thing_with_delimeters(string_to_find, left_delim, delim, right_delim, search_string):

	left_delim = re.escape(left_delim)
	right_delim = re.escape(right_delim)

	block = re.match(".*"+string_to_find+" = "+left_delim+"(?P<things>.*)"+right_delim+";", search_string);

	thing_dict = {}
	if block:
		things = block.group("things").split(delim)
		for thing in things:
			match = re.match("(?P<id>.*) \/\* (?P<thing_name>.*) \*\/?", thing.strip())
			if match:
				thing_dict[match.group("thing_name")] = match.group("id")
	else:
		return

	return thing_dict

def get_array_with_delimeters(string_to_find, left_delim, delim, right_delim, search_string):

	left_delim = re.escape(left_delim)
	right_delim = re.escape(right_delim)

	block = re.search("\s+"+string_to_find+" = "+left_delim+"(?P<things>.*?)"+right_delim+";", " "+search_string);

	thing_array = []
	if block:
		things = block.group("things").split(delim)
		for thing in things:
			match = re.search("(?P<id>.*)", thing.strip())
			if match:
				if match.group("id")!= '':
					thing_array.append(match.group("id"))
	else:
		return

	return thing_array

def get_value_for_property(property_name, search_string):

	result = re.search("\s+"+property_name+" = \"+(?P<value>[^,;]*?)\";", " "+search_string)
	if result:
		return result.group("value")
	else:
		result = re.search("\s+"+property_name+" = (?P<value>[^,;]*?);", " "+search_string)
		if result:
			return result.group("value")

	return

def add_lines_between_match(lines, match, match_target_string):

	match_target_string = match_target_string[:match.end()] + lines + match_target_string[match.end():]

	return match_target_string

def get_id_for_named_thing(project_data, name):
	match = re.search("(?P<ID>[A-Z0-9]+?) \/\* " + name + " \*\/ = \{", project_data)
	if match:
		return match.group("ID")

###########################################

## File Locating ##########################
def locate_xcode_project(root, levels_to_search):
	
	for file in list(recursive_file_gen(root)):
			if fnmatch.fnmatch(file, '*.xcodeproj'):
				user_response = 'fail'
				while user_response == 'fail':
					user_response = raw_input('Is ' + file + ' the corresponding xcode project file for your target application? [y/n/a(bort)]: ')
					if user_response.lower() == 'y':
						return file
					if user_response.lower() == 'a':
						print 'Aborting installation...'
						abort_install()
					if user_response.lower() != 'n':
						user_response = 'fail'

	if (levels_to_search > 0):
		return locate_xcode_project(root+'/../', levels_to_search-1)
	else:
		print 'No valid xcode project files found within or near' + os.path.abspath(root)
		print 'Please relocate the artisan_installer script to the same directory as your target xcode project file.'
		return ''

def locate_app_delegate(root, levels_to_search):

	for file in list(recursive_file_gen(root)):
		if fnmatch.fnmatch(file, '*AppDelegate.m'):
			user_response = 'fail'
			while user_response == 'fail':
				user_response = raw_input('Is ' + file + ' the corresponding application delegate (.m) file for your target application? [y/n/a(bort)]: ')
				if user_response.lower() == 'y':
					return file
				if user_response.lower() == 'a':
					print 'Aborting installation...'
					return ''
				if user_response.lower() != 'n':
					user_response = 'fail'

	if (levels_to_search > 0):
		return locate_app_delegate(root+'/../', levels_to_search-1)
	else:
		print 'No valid application delegate files found within or near ' + os.path.abspath(root)
		return ''

def recursive_file_gen(mydir):
	for root, dirs, files in os.walk(mydir):
		for file in files:
			yield os.path.join(root, file)
		for dir in dirs:
			yield os.path.join(root, dir)

def matches_did_finish_launching(line):

	regex_to_find = '(\s*-\s*\(\w+\)\s*application\s*:\s*\(UIApplication\s*\*\)\s*\w+\s*didFinishLaunchingWithOptions\s*:\s*\(NSDictionary\s*\*\)\s*\w+)(.*)'
	return re.match(regex_to_find, line)

def verify_app_delegate(app_delegate_path):

	for line in fileinput.input(app_delegate_path):
		if matches_did_finish_launching(line):
			fileinput.close()
			return True

	fileinput.close()
	return False

###########################################

## Clean Up ###############################

def remove_old_resource(resource_name, project_data):
	
	pattern = '.*\/\* '+re.escape(resource_name)+'.*\*\/.*'
	matches = re.findall(pattern, project_data)
	project_data = re.sub(pattern, '', project_data)

	if matches:
		print '  - removing file references to ' + resource_name
	return project_data

def remove_old_resources(root, project_data):
	for file in list(recursive_file_gen(root)):
		if fnmatch.fnmatch(file.lower(), '*/artisananalytics.bundle'):
			print '  - deleting: ' + file
			shutil.rmtree(file)
		if fnmatch.fnmatch(file.lower(), '*/artisansdk.bundle'):
			print '  - deleting: ' + file
			shutil.rmtree(file)
		if fnmatch.fnmatch(file.lower(), '*/artisansdk.framework'):
			print '  - deleting: ' + file
			shutil.rmtree(file)
		if fnmatch.fnmatch(file.lower(), '*/aruxflip.bundle'):
			print '  - deleting: ' + file
			shutil.rmtree(file)
		if fnmatch.fnmatch(file.lower(), '*/aruxflip.framework'):
			print '  - deleting: ' + file
			shutil.rmtree(file)
		if fnmatch.fnmatch(file.lower(), '*/artisan.xcconfig'):
			print '  - deleting: ' + file
			os.remove(file)

	project_data = remove_old_resource("ARUXFLIP.bundle", project_data)
	project_data = remove_old_resource("ARUXFLIP.framework", project_data)
	project_data = remove_old_resource("ArtisanAnalytics.bundle", project_data)
	return project_data

## file downloading ############################

def download_url(url_source, file_destination):

	file_chunk_size = 8 * 1024
	demarcations = 100

	try:
		request = urllib2.urlopen(url_source)
	except urllib2.URLError, e:
		print 'Failed to download Artisan resources.'
		print str(e.code)
		print 'Terminating installation...'
		abort_install()
	except ValueError, e:
		print 'Unable to download Artisan resources.'
		print url_source + ' is not a valid URL.'
		print 'Terminating installation...'
		abort_install()

	file_size = request.info()['Content-Length']
	loop_iterations = int(request.info()['Content-Length']) / file_chunk_size

	iteration = 0
	print '\nDownloading ' + os.path.basename(url_source) + ' to ' + file_destination + ': [' + str(int(file_size)/1024) + 'kB]'
	with open(file_destination, 'wb') as file_pointer:
		#shutil.copyfileobj(request, file_pointer, file_chunk_size)
		chunk = request.read(file_chunk_size)
		file_pointer.write(chunk)
		while (chunk):
			stdout.write("\r")

			if iteration == loop_iterations:
				percent_complete = 100
			else:
				percent_complete = int(float(iteration) * (float(demarcations) / float(loop_iterations)))

			for mark in range(1,demarcations):
				if mark <= percent_complete:
					stdout.write(unichr(0x2588))
				else:
					stdout.write(unichr(0x2591))

			stdout.write('  %d %%' % percent_complete)
			stdout.flush()
			iteration = iteration + 1
			chunk = request.read(file_chunk_size)
			file_pointer.write(chunk)

		stdout.write("\n")
	print 'Complete!\n'

def untar_file(file_to_untar, destination):
	print '\nUntarring downloaded resources to ' + destination + '...'
	tar_file = tarfile.open(file_to_untar, 'r:gz')
	tar_file.extractall(destination)

	clean_up_untar()

def clean_up_untar():
	print '\nRemoving artisan_resources.tar.gz...'
	os.remove('artisan_resources.tar.gz')

def locate_downloaded_resources(root):

	for file in list(recursive_file_gen(root)):
		if fnmatch.fnmatch(file.lower(), '*/artisansdk.bundle'):
			return os.path.split(os.path.abspath(file))[0]
	return ''

#########################################

## Options Parsing ########################

def create_options_parser():

	usage = '%prog [options]\n\n'+'Artisan Installer\n'+'version: ' + installer_version + '\n'

	parser = OptionParser(usage = usage)
	parser.add_option("-p", "--project", dest="project", help="Set the target project to which to add Artisan.")
	parser.add_option("-x", "--xcode-version", dest="xcode_version", help="Set the Xcode version you plan to open this project in. By default, the installer uses xcodebuild to determine your latest Xcode version.")
   	parser.add_option("-c", "--config", dest="configs", help="Specify the build configurations to add Artisan to (example: Debug). By default, the installer add Artisan to every configuration for the given target.", action="append")
	parser.add_option("-d", "--delegate", dest="app_delegate", help="Set the path to the appDelegate.")
	parser.add_option("-k", "--key", dest="artisan_key", help="Set the Artisan key for this project.")
	parser.add_option("-v", "--version", dest="version", help="Set the version number to represent the appropriate build.")
	parser.add_option("-r", "--resource", dest="resource_url", help="Set the URL for the Artisan resource download location.")
	parser.add_option("-t", "--target", dest="application_target", help="Set the application build target.")

	return parser

def process_options(options, script_location):

	global artisan_key, artisan_version, resource_download_url, xcode_project_path

	settings = {
	"xcode_project_path":options.project,
	"app_delegate_path":options.app_delegate,
	"artisan_key":artisan_key,
	"artisan_version":artisan_version,
	"xcode_version":"",
	"resource_download_url":resource_download_url,
	"application_target":options.application_target
	}

	if settings["xcode_project_path"]:
		if not os.path.exists(settings["xcode_project_path"]):
			print 'The file you have indicated as your xcode project file ('+ settings["xcode_project_path"] +') does not exist.'
			print 'Terminating installation.'
			abort_install()

	if settings["app_delegate_path"]:
		if not os.path.exists(settings["app_delegate_path"]):
			print 'The file you have indicated as your application delegate .m file ('+ settings["app_delegate_path"] +') does not exist.'
			print 'Terminating installation.'
			abort_install()
	
	if (options.application_target):
		settings["application_target"] = options.application_target

	levels_to_search = 2

	if not settings["xcode_project_path"]:
		settings["xcode_project_path"] = locate_xcode_project(script_location, levels_to_search)
	
	if not settings["xcode_project_path"]:
		print 'Aborting installation...'
		print 'You must specify an Xcode project file. Either use the -p argument, or choose an acceptable (*.xcodeproj) file during the install process.'
		abort_install()
		return
	
	if not settings["app_delegate_path"]:
		settings["app_delegate_path"] = locate_app_delegate(script_location, levels_to_search)

	if not settings["app_delegate_path"]:
		print 'Aborting installation...'
		print 'You must specify an application delegate file. Either use the -d argument, or choose an acceptable (*.m) file during the install process.'
		abort_install()
		return

	if not verify_app_delegate(settings["app_delegate_path"]):
		print 'Terminating installation...'
		print 'The file you designated as your application delegate ('+ settings["app_delegate_path"] +') appears to be an invalid application delegate implementation file.'
		return

	if not settings["resource_download_url"]:
		print 'Aborting installation...'
		print 'You must specify a url from which to download the Artisan resource files. This should be provided when this file was downloaded.'
		return
	else:
		if options.resource_url:
			settings["resource_download_url"] = options.resource_url

	if not settings["artisan_key"]:
		print 'Aborting installation...'
		print 'You must specify a key for Artisan to install correctly. This key should have been injected into this script when downloaded. If not, you may use the -k argument to pass in the key from the Artisan website.'
		return
	else:
		if options.artisan_key:
			settings["artisan_key"] = options.artisan_key

	if not settings["artisan_version"]:		
		print 'Aborting installation...'
		print 'You must specify the Artisan version attached to your application to install Artisan correctly. This version number should have been injected into this script when downloaded. If not, you may use the -v argument to pass in the version from the Artisan website.'
		return
	else:
		if options.version:
			settings["artisan_version"] = options.version
		
	# if xcode version was not specified, determine the currently installed version and use that for building.
	if not settings["xcode_version"]:
		f=os.popen("xcodebuild -version")
		xcodebuild_version = f.readlines()[0]
		match = re.search('Xcode ([a-zA-Z0-9.]+)', xcodebuild_version)
		if match:
			(settings["xcode_version"], ) = match.groups()

	xcode_project_path = settings["xcode_project_path"]

	return settings

## Installation ###############################

def add_artisan_line_to_file(app_delegate_file_name, artisan_app_id, artisan_version):
		processing_import = False
		processing_app_did_finish_launching = False
		processing_return_yes = False

		header_file_name = os.path.basename(app_delegate_file_name.replace('.m', '.h'))

		start_up_line = '[ARManager startWithAppId:@"'+artisan_app_id+'" version:@"'+ artisan_version +'" options:nil];'

		# we will always remove any old lines we have inserted
		should_add_start_up_line = True
		should_add_import_line = True

		_fail_on_import_line = True
		_fail_on_artisan_line = True

		pre_return_yes_code = '';
		old_return_yes_code = '';

		#copy old file as back up
		backup_file_name = str.replace(app_delegate_file_name, '.m', '.bak')
		shutil.copyfile(app_delegate_file_name, backup_file_name)

		for line in fileinput.input(app_delegate_file_name, inplace=1):
			if line.startswith('#import "'+header_file_name+'"'):
				processing_import = True

			matches = matches_did_finish_launching(line)
			if matches:
				processing_app_did_finish_launching = True

			# remove old comments
			if re.search("^.*\/\* Artisan Manager start-up code; please note, if you have multiple exit points in this method.*$", line):
				continue
			if re.search("^.*\* you will need to copy and paste the ARManager call before each occurrence of return YES \*\/.*$", line):
				continue

			return_yes_line_matches = re.search("^(.*)return YES;.*$", line)
			if return_yes_line_matches and processing_app_did_finish_launching:
				old_return_yes_code = return_yes_line_matches.group(0).strip()
				pre_return_yes_code = return_yes_line_matches.group(1).strip()
				old_artisan_start_line = re.search(".*(\{ \[ARManager startWithAppId:.*\];).*", pre_return_yes_code)
				if old_artisan_start_line:
					pre_return_yes_code = pre_return_yes_code.replace(old_artisan_start_line.group(1), '')
				processing_return_yes = True
				stdout.write('    - removing ' + old_return_yes_code + '\n');
				continue

			if processing_import & should_add_import_line:
				print '#import <ArtisanSDK/ArtisanSDK.h>'
				_fail_on_import_line = False
				processing_import = False

			if re.search("^.*import <ArtisanSDK/ArtisanSDK.h>.*$", line):
				continue
			if re.search("^.*import <ARUXFLIP/ARUXFLIP.h>.*$", line):
				continue

			if processing_app_did_finish_launching & processing_return_yes & should_add_start_up_line:
				#print '\t'+start_up_line
				print '\t/* Artisan Manager start-up code; please note, if you have multiple exit points in this method'
				print '\t * you will need to copy and paste the ARManager call before each occurrence of return YES */'
				print '\t' + pre_return_yes_code + '{ ' + start_up_line + ' return YES;' + ' }'
				stdout.write('    + adding comments...\n')
				stdout.write('    + adding ' + pre_return_yes_code + '{ ' + start_up_line + ' return YES;' + ' }\n')
				_fail_on_artisan_line = False
				processing_return_yes = False
				processing_app_did_finish_launching = False
			if processing_return_yes:
				processing_curly_brace = False

			ar_manager_matches = re.search("^.*\[ARManager startWithAppId:.*$", line)
			if ar_manager_matches:
			# if line.startswith('\t[ARManager startWithAppId:@"') and should_add_start_up_line:
				continue
			else:
				print line,
		fileinput.close()

		# if newly written file is smaller than backup, then something went wrong
		# restore backup file and cancel installation
		#if os.path.getsize(backup_file_name) > os.path.getsize(app_delegate_file_name):
		if _fail_on_artisan_line or _fail_on_import_line:
			shutil.copyfile(backup_file_name, app_delegate_file_name)
			os.remove(backup_file_name)
			print '\n *!* Failed to add necessary lines of code to your application delegate. Restoring the file to previous state. Your file may be corrupt. Please contact Artisan Support. *!*'
			abort_install()

		os.remove(backup_file_name)

def verify_resource_exists(resource, path_to_resource):
	
	if path_to_resource.startswith("/"):
		local_path = path_to_resource
	else:
		local_path = xcode_project_path + "/../" + path_to_resource

	file_path = None

	for root, dirs, files in os.walk(local_path):
		for a_file in files:
			if a_file == resource:
				file_path = os.path.join(root, a_file)
				break;
		if file_path:
			break;
		for a_dir in dirs:
			if a_dir == resource:
				file_path = os.path.join(root, a_dir)
				break;

	if not file_path:
		file_path = local_path + "/" + resource;

	local_path = file_path;

	while not os.path.exists(local_path):
		print '\nArtisan was unable to locate the path to your ' + resource + ' at '+ path_to_resource +'. This is a required library and should be present on all OSX systems.'
		path_to_resource = raw_input('Please enter the path where ' + resource + ' resides on your file system (ex: /usr/lib/path/to/ or enter nothing to abort): ')
		if (path_to_resource == ''):
			print 'Terminating installation...'
			abort_install()

	return path_to_resource

def get_ids_for_phase(project_data, phase):
	
	pattern_to_find = "\/\* Begin PBX" + phase + "BuildPhase section \*\/.*?\n\t\t(?P<ID>[A-Z0-9]+?) \/\* (?P<framework_name>.*?) \*\/ = \{.*?files = \("
	compiled_pattern = re.compile(pattern_to_find, re.MULTILINE | re.DOTALL)

	matches = re.finditer(compiled_pattern, project_data)
	framework_phase_ids = []
	for match in matches:
		framework_phase_ids.append(match.group("ID"))
	
	return framework_phase_ids

def verify_framework_added(resource, project_data, target_group, settings):
	pattern_to_find = "\/\* Begin PBXBuildFile section \*\/.*?\n\t\t(?P<ID>[A-Z0-9]+?) \/\* " + resource + " .*? \*\/ = \{.*End PBXBuildFile section"
	compiled_pattern = re.compile(pattern_to_find, re.MULTILINE | re.DOTALL)

	match = re.search(compiled_pattern, project_data)
	if match:
		resource_id = match.group("ID")
	else:
		resource_id = get_hash_base(resource) + "1"
		file_reference_id = get_id_for_named_thing(project_data, resource)
		(project_data, removed2) = remove_build_file(resource, project_data)
		(project_data, success2) = add_build_file(resource, file_reference_id, resource_id, target_group, project_data)

	if target_group == "Frameworks":
		for build_phase_id in settings["framework_build_phase_ids"]:
			project_data = add_file_to_phase(project_data, resource, resource_id, target_group, build_phase_id)

	if target_group == "Resources" or target_group == "Artisan":
		for build_phase_id in settings["resource_build_phase_ids"]:
			project_data = add_file_to_phase(project_data, resource, resource_id, target_group, build_phase_id)
	
	return project_data

def add_resources(resources, resource_path, resource_type, project_data, project_file_path, build_phase, target_group, source_tree, settings):
	group_id = get_id_for_named_thing(project_data, target_group)

	for resource in resources:
		user_resource_path = verify_resource_exists(resource, resource_path)
		hash_base = get_hash_base(resource);

		file_reference_id = hash_base + "0"
		build_reference_id = hash_base + "1"

		(project_data, removed) = remove_file_reference(resource, project_data)
		(project_data, success) = add_file_reference(resource, file_reference_id, resource_type, user_resource_path, project_data, project_file_path, source_tree)
		
		if success:	
			(project_data, removed2) = remove_build_file(resource, project_data)
			(project_data, success2) = add_build_file(resource, file_reference_id, build_reference_id, target_group, project_data)		

		if not success or not success2:			
			project_data = verify_framework_added(resource, project_data, target_group, settings)

		if removed:
			print "    = " + resource + " already added"
		else: 
	 		print "    + " + resource + " added"

		# add to correct group
		project_data = add_file_to_group(project_data, resource, file_reference_id, target_group)

		# add to build phase
		if build_phase == "Frameworks":
			for build_phase_id in settings["framework_build_phase_ids"]:
				project_data = add_file_to_phase(project_data, resource, build_reference_id, build_phase, build_phase_id)
		elif build_phase == "Resources":
			for build_phase_id in settings["resource_build_phase_ids"]:
				project_data = add_file_to_phase(project_data, resource, build_reference_id, build_phase, build_phase_id)
		else:
			project_data = add_file_to_phase(project_data, resource, build_reference_id, build_phase, build_phase_id)

	return project_data

def add_required_frameworks(project_data, settings):

	frameworks_to_add = ["CoreData.framework", "CFNetwork.framework", "Security.framework", "QuartzCore.framework","SystemConfiguration.framework", "CoreLocation.framework"]
	ui_kit_path = "/System/Library/Frameworks"

	print "\n  Required Frameworks:"

	project_data = add_resources(frameworks_to_add, ui_kit_path, "wrapper.framework", project_data, settings["xcode_project_path"], "Frameworks", "Frameworks", "SDKROOT", settings)

	dylibs_to_add = ["libz.dylib"]
	dylib_root_path = "/usr/lib"

	project_data = add_resources(dylibs_to_add, dylib_root_path, "compiled.mach-o.dylib", project_data, settings["xcode_project_path"], "Frameworks", "Frameworks", "SDKROOT", settings)

	return project_data

def add_artisan_framework(project_data, settings):

	frameworks_to_add = ["ArtisanSDK.framework"]
	project_data = add_resources(frameworks_to_add, settings["artisan_resources_relative_to_xcodeproj"], "wrapper.framework", project_data, settings["xcode_project_path"], "Frameworks", "Artisan", "\"<group>\"", settings)

	hash_base = get_hash_base("ArtisanSDK.framework");
	build_reference_id = hash_base + "1"

	return project_data

def add_artisan_bundles(project_data, settings):

	bundles_to_add = ["ArtisanSDK.bundle"]
	print "\n  Artisan Bundle Resources:"
	project_data = add_resources(bundles_to_add, settings["artisan_resources_relative_to_xcodeproj"], "wrapper.plug-in", project_data, settings["xcode_project_path"], "Resources", "Artisan", "\"<group>\"", settings)
	return project_data

def update_build_settings_for_config_files(project_data, settings):
	
	config_file_list = find_config_files(settings)
	path_to_config_file = settings["artisan_resources_folder_path"]+"/Artisan.xcconfig"

	if not os.path.isfile(path_to_config_file):
		print "    + creating new Artisan.xcconfig file"
		write_artisan_xcconfig(settings)

		config_id = get_hash_base("Artisan.xcconfig")+"0"
		(project_data, success) = add_file_reference('Artisan.xcconfig', config_id, "text.xcconfig", path_to_config_file, project_data, settings["xcode_project_path"], "\"<group>\"")
		
		if success:
			project_file = open(settings["project_file"], 'w')
			project_file.write(project_data)
			project_file.close()
		
		print "    + added file reference to Artisan.xcconfig"
	else:
		print "    = found existing Artisan.xcconfig file"

	for file_name in config_file_list:
		print "    + modifying " + os.path.split(file_name)[0] + " for use with Artisan"
		undo_other_ldflags(file_name)
		remove_artisan_xcconfig(file_name, settings)
		replace_other_ldflags(file_name)
		add_artisan_config(file_name, settings)

	return project_data

def modify_build_settings(project, settings):
	for key, value in project["targets"].items():
		for k,v in value["buildConfigurations"].items():
			if not v["baseConfigurationReference"]:
				add_property_to_id(settings["project_file"], v["id"], "OTHER_LDFLAGS", "-ObjC")
				add_property_to_id(settings["project_file"], v["id"], "FRAMEWORK_SEARCH_PATHS", "\\\"$(SRCROOT)/resources\\\"")
				add_property_to_id(settings["project_file"], v["id"], "HEADER_SEARCH_PATHS", "\\\"$(BUILT_PRODUCTS_DIR)/../../Artisan\\\"");
				add_property_to_id(settings["project_file"], v["id"], "HEADER_SEARCH_PATHS", "\\\"$(BUILT_PRODUCTS_DIR)/../Artisan\\\"");
				add_property_to_id(settings["project_file"], v["id"], "HEADER_SEARCH_PATHS", "\\\"$(SRCROOT)/resources\\\"");

def check_configuration_files(project, settings):

	should_update_configs = False
	should_modify_build_settings = False
	for key, value in project["targets"].items():
		for k,v in value["buildConfigurations"].items():
			if v["baseConfigurationReference"]:
				should_update_configs = True
			else:
				should_modify_build_settings = True


	if should_update_configs:
		print '  Configuration Files:'
		print '  We have detected that you have a configuration file set on one or more of your project\'s targets.'
		print '  Artisan can modify these files to work properly, but if they change via direct editing or a tool such as Cocoa Pods pod update/install command you may need to run the Artisan installer again.'
		print '  Adding a configuration file to a target after installing Artisan may cause your build to break. Here is a list of the changes that Artisan needs to make to work:\n'
		print '   * OTHER_LDFLAGS = "-ObjC" (Other Linker Flags in build settings)'
		print '   * FRAMEWORK_SEARCH_PATHS = "$(SRCROOT)/resources" (Framework Search Paths in build settings)'
		print '   * HEADER_SEARCH_PATHS = "$(BUILT_PRODUCTS_DIR)/../../Artisan" (Header Search in build settings)'
		print '   * HEADER_SEARCH_PATHS = "$(BUILT_PRODUCTS_DIR)/../Artisan" (Framework Search in build settings)'
		print '   * HEADER_SEARCH_PATHS = "$(SRCROOT)/resources" (Framework Search Paths in build settings)\n'
		print '  Artisan modifies the target properties directly if no configuration file has been set on a given target. If a configuration were present, this would override values set by the configuration file. The installation should succeed, but we just wanted to let you know what\'s going on.'
		user_response = "not_valid"
		while user_response == "not_valid":
			user_response = raw_input('Do you wish to proceed with the installation? (y/n): ')
			if user_response.lower() == 'y':
				continue
			if user_response.lower() == 'n':
				print "Aborting installation."
				abort_install()

			user_response = "not_valid"

	project_data = get_project_data(settings["project_file"])
		
	## Remove any old Artisan resources		
	print "\nRemoving old Artisan resources"
	project_data = remove_old_resources(settings["xcode_project_containing_path_real"], project_data)
	project_file = open(settings["project_file"], 'w')
	project_file.write(project_data)
	project_file.close()
	## Download the latest...
	download_url(resource_download_url, 'artisan_resources.tar.gz')

	# extract files to correct locations
	untar_file('artisan_resources.tar.gz', settings["xcode_project_containing_path_real"])

	# Determine our relative paths...
	settings["artisan_resources_folder_path"] = locate_downloaded_resources(settings["xcode_project_containing_path_real"])
	settings["artisan_resources_relative_to_xcodeproj"] = os.path.relpath(settings["artisan_resources_folder_path"], settings["xcode_project_containing_path_real"])
	
	if should_update_configs:	
		print "\n  Configuration Updates:"
		update_build_settings_for_config_files(project_data, settings)

	if should_modify_build_settings:
		print '\nBuild Settings:'
		modify_build_settings(project, settings)

def abort_install():

	project_data = get_project_data('old_proj_file')

	global xcode_project_path

	if xcode_project_path and os.path.isfile('old_proj_file') and project_data:
		project_file = open(xcode_project_path+"/project.pbxproj", 'w')
		project_file.write(project_data)
		project_file.close()
		os.remove("old_proj_file")

	sys.exit()


def install_artisan(project, project_data, settings):

	print "Settings" 
	
	print '\nAdding Artisan to ' + os.path.split(settings["xcode_project_path"])[0] + '...\n'
	print 'Settings: \n'
	print '  Artisan key: ' + settings["artisan_key"]
	print '  App Version: ' + settings["artisan_version"]
	print '  XCode Project Location: ' + settings["xcode_project_path"]
	print '  AppDelegate Location: ' + settings["app_delegate_path"]
	if settings["application_target"]:
		print '  Application Target: ' + settings["application_target"]
	else:
		print '  Application Target: All Targets'

	check_configuration_files(project, settings)

	project_data = get_project_data(settings["project_file"])
	
	artisan_group_id = get_hash_base("Artisan")+"0"
	settings["artisan_group_id"] = artisan_group_id

	framework_build_phase_ids = get_ids_for_phase(project_data, "Frameworks")
	settings["framework_build_phase_ids"] = framework_build_phase_ids

	resource_build_phase_ids = get_ids_for_phase(project_data, "Resources")
	settings["resource_build_phase_ids"] = resource_build_phase_ids

	project_data = add_group("Artisan", artisan_group_id, project_data)
	project_data = add_file_reference_to_group_id("Artisan", artisan_group_id, project["mainGroupId"], project_data)

	project_data = add_required_frameworks(project_data, settings)

	project_data = add_artisan_framework(project_data, settings)

	project_data = add_artisan_bundles(project_data, settings)

	print '\n modifying the following lines in ' + os.path.basename(settings["app_delegate_path"]) + ': '
	add_artisan_line_to_file(settings["app_delegate_path"], settings["artisan_key"], settings["artisan_version"])

	project_file = open(settings["project_file"], 'w')
	project_file.write(project_data)
	project_file.close()

	print '\nComplete!'

##############################################
def main():

	## Collect User Input for Installation
	parser = create_options_parser()	
	(options, args) = parser.parse_args()

	installer_file_location = os.path.realpath(__file__+'/../')
	settings = process_options(options, installer_file_location)

	## Important and useful paths...	
	settings["xcode_project_path"] = os.path.realpath(settings["xcode_project_path"])
	settings["xcode_project_containing_path"] = os.path.relpath(settings["xcode_project_path"]+'/../')
	settings["xcode_project_containing_path_real"] = os.path.realpath(settings["xcode_project_path"]+'/../')
	settings["project_file"] = settings["xcode_project_path"]+"/project.pbxproj"

	project = get_project_build_info(settings["project_file"])
	project_data = get_project_data(settings["project_file"])

	# save old for abort
	old_proj_file = open("old_proj_file", 'w+')
	old_proj_file.write(project_data);
	old_proj_file.close();

	install_artisan(project, project_data, settings)

	os.remove("old_proj_file")

if __name__ == "__main__":
	sys.exit(main())
